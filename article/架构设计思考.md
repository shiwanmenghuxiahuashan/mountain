# 目前遇到的问题

着手开发基于vue 3.x 框架的项目以来，不断的推翻已有规划，因为总觉得不够完美和适用性不够强，也在面临了新需求的挑战，和不断整合进来的业务需求，导致不能够规范化生产。

## 业务逻辑和数据访问

vue 很好很优秀，问题不在于框架的选用而是在于使用者身上, vue的核心库只关注视图层，但是还有业务逻辑层和数据访问层([三层架构 ](https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84))，vue本身并没有规定，或考虑如何设计业务逻辑层和数据访问层，这是前端设计架构的时候着重考虑的问题。如果按着vue的框架写就好，不用管其他，怎么方便怎么来的思维，最后带来的后果就是代码只有开发者自己看的懂，一处修改处处bug，不利于多人协作，代码逻辑不清，可维护性、稳定性差，不易分工等常见问题。

## 数据的不确定性

前端的数据都是发送请求到后端，然后由后端返回。这中间会涉及到的问题是：后端返回的数据却不一定是前端想要的格式或者字段。虽然通过JSON: API统一了数据的载体形式，确立了标准，但并非业务需要的数据，例如：解析数据为列表格式，option选项格式，treeview 格式，或者其他特定格式等等，仍然涉及到前端对业务数据的处理与加工，并在最终将要提交到后端的数据重新加工，以符合JSON: API标准的数据。

随之而来问题就是，有些复杂度程度高，书写不规范的代码，很容易出现“牵一发而动全身”情况。在业务逻辑简单，规模还小的前期写的时候可以随心所欲的写，写的很快，等后期项目膨胀就发展成各种问题不断，“按下葫芦浮起瓢”，开发者成了救火队员，处处灭活，无暇顾及需求变更了。

# 目标

前端部分规划架构，使得前端代码，更加清晰易维护，便于多人分工协作开发，降低系统复杂度。

* 规范化：不同的团队成员会以不同的方式解决问题。这导致在代码审查、代码更改等方面花更多的时间的讨论。为了让免于这一切，我们着手建立一个框架，该框架规范标准的实现指导方针，同时又不会过于严格。

* 快速融入：应该允许新的团队成员在有必要知识储备下很容易地参与到项目中。

* 可维护&稳定性：要么足够简单没有BUG，要么极其复杂发现不了BUG，我们选择前者，把复杂的问题简单化，降低维护成本而且更稳定。
# 实现

## 组件 components

目录结构调整
2020/12/05，调整目录结构如下：

```
├── build                      // 构建相关  
├── config                     // 配置相关
├── public
    ├──static                  // 第三方不打包资源
├── src                        // 源代码
│   ├── api                    // 所有请求
│   ├── assets                 // 主题 字体等静态资源
│   ├── components             // 全局公用组件
│       ├── companyName              //companyName封装通用项目组件
│       ├── app                //app 业务组件
│   ├── directive              // 全局指令
│   ├── icons                  // 项目所有 svg icons
│   ├── router                 // 路由
│   ├── store                  // 全局 store管理
│   ├── styles                 // 全局样式
│   ├── utils                  // 全局公用方法
│   ├── views                  // view 抽象view，符合大多数的布局结构
│   ├── pages                  // page  业务向，page是view的实例
│   ├── App.vue                // 入口页面
│   ├── main.js                // 入口 加载组件 初始化等
├── .babelrc                   // babel-loader 配置
├── .gitignore                 // git 忽略项
└── package.json               // package.json
```

pages，views 与 components

pages 是与业务有耦合关系的，并带有适配数据功能的，业务"页面"。
view 是有 API 接口性质，组织组件关系，逻辑，向上数据流
components 组件，最小业务单元封装

单文件组件封装
我们确立一个标准，由开发人员共同去遵守，然后去开发，更新，维护，确保符合标准组件输出到项目中，从而帮助我们把重心应从繁杂的样式，交互处理中解放出来，关心业务实现，用户体验。

data“流速”
“流速”-业务逻辑从需求到实现/一份数据从来源，经过用户操作，加工，生产，再返回到来源处的过程。

view  
view  是 ui 设计，css 样式 ，HTML 结构，信息展示，组织组件布局的综合产物。
要对具有相似性的 ui 设计、HTML 结构布局进行归纳总结，对其进行抽象，封装，归纳其共性。

哪些应该封装成组件？
影响“流速”的，涉及到 action，data，view 的三者紧密耦合的，天然就是组件，例如一个异步加载的模态框，它有数据加载（只加载自己所用的数据），可视 UI（不同数据可能显示的 UI 形式也不一样），关闭操作（只涉及到组件本身的行为操作）。而且它一次封装，多处复用，提升数据流速。

而纯粹的数据处理，适配不应该封装为组件，它没有 view 和 action。

由业务需求而来的，复杂，且变化定制 view 应该封装，虽然它本身不包含数据或生产数据，但是他是数据的重要表现形式，它加工计算数据，以将数据可视化，结构化。例如一个 gant 表格，源数据会给出起始日期，结束日期和进度，但是其中表示进度占比的进度条长度，则需要们在组件内部根据源数据加工计算得出。

重复且大量的纯 view，不应该封装为单文件组件，应作为函数式组件，或静态模板处理。

并且，涉及到源数据的组件，应该在会上一起探讨、确定，因为涉及到数据接口。

组件封装规范
为了回避错误、小纠结和反模式，提升开发效率，减少沟通杂音。

目录规范
所有项目级通用组件都应存放在 src\components\companyName 目录下：
//....
├── src                        // 源代码
│   ├── components             // 全局公用组件
│       ├── companyName              //companyName封装通用项目组件
│       ├── app                //app 业务组件
//.....

组件内目录结构
src 中存放的是组件的子组件，例如 TodoList 的子组件，TodoItem.vue, Panel 的子组件 PanelDefault.vue 或多态组件 media.vue
//....
├── src                        // 源代码
│   ├── components             // 全局公用组件
│       ├── companyName              //companyName封装通用项目组件
│          ├── Panel
│               ├──Panel.vue //主vue
│               ├──src              //子组件/多态组件文件夹             
│       ├── app                //app 业务组件
//.....

命名规范
组件名称应该以高阶的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。
|- SearchButtonClear.vue
|- SearchButtonRun.vue
|- SearchInputQuery.vue
|- SearchInputExcludeGlob.vue
|- SettingsCheckboxTerms.vue
|- SettingsCheckboxLaunchOnStartup.vue

组件命名

单文件组件的文件名始终是单词大写开头 (PascalCase)
export default {
  name: 'Panel', 
  // ...
}

只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性。 
components/app
|- TheHeading.vue
|- TheSidebar.vue

紧密耦合的组件名称, 和父组件紧密耦合的子组件应该以父组件名作为前缀命名。
//父组件 TodoList/TodoList.vue
export default {
  name: 'TodoList', 
  // ...
}
//子组件 TodoList/src/TodoListItem.vue
export default {
  name: 'TodoListItem', 
  // ...
}

多态件命名
多态件命名以其状态命名
